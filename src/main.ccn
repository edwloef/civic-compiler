start phase RootPhase {
    actions {
        pass scanparse;
        // Print;
        // Stats;
        Analysis;
        Desugar;
        Opt;
        Free;
    }
};

traversal Print {
    uid = PRT
};

phase Stats {
    actions {
        traversal CountOps {
            uid = SCO,
            nodes = { BinOp },
            travdata {
                int add,
                int sub,
                int mul,
                int div,
                int mod
            }
        };

        traversal CountIdents {
            uid = SCI,
            nodes = { Id },
            travdata {
                user htable_st_ptr count
            }
        };
    }
};

phase Analysis {
    actions {
        traversal Collect {
            uid = AC,
            nodes = { Program, FunDecl, FunBody, VarDecl },
            travdata {
                user funtable_ptr funtable,
                user vartable_ptr vartable,
                int nesting_level
            }
        };

        traversal Resolve {
            uid = AR,
            nodes = { Program, FunDecl, FunBody, Param, VarDecl, For, Call, VarRef },
            travdata {
                user funtable_ptr funtable,
                user vartable_ptr vartable,
                int nesting_level
            }
        };

        traversal TypeCheck {
            uid = ATC,
            nodes = ArrExpr | Stmt | { Program, Stmts, FunDecl, FunBody, VarDecl },
            travdata {
                user funtable_ptr funtable,
                user vartable_ptr vartable,
                BasicType ret_ty
            }
        };
    }
};

phase Desugar {
    actions {
        traversal Casts {
            uid = DC,
            nodes = { Cast }
        };
    }
};

cycle Opt {
    actions {
        traversal ScalarConstFold {
            uid = OSCF,
            nodes = { Monop, Binop, Cast }
        };

        cycle ComputeTransp {
            actions {
                traversal Transp {
                    uid = OCTT,
                    nodes = ArrExpr | { Program, FunDecl, FunBody, Assign, Exprs },
                    travdata {
                        user funtable_ptr funtable,
                        user vartable_ptr vartable,
                        int nesting_level,
                        int min_nesting_level
                    }
                };
            }
        };

        traversal TrivialControlFlow {
            uid = OTCF,
            nodes = { Stmts }
        };

        traversal Identities {
            uid = OI,
            nodes = { Monop, Binop }
        };
    }
};

traversal Free {
    uid = F,
    nodes = { Program, Fundecl, Funbody }
};

enum BasicType {
    prefix = TY,
    values {
        bool, int, float, void, error
    }
};

enum MonOpKind {
    prefix = MO,
    values {
        pos, neg, not
    }
};

enum BinOpKind {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne, and, or
    }
};

root node Program {
    children {
        Decls decls { constructor, mandatory }
    },

    attributes {
        user funtable_ptr funtable,
        user vartable_ptr vartable
    }
};

node Decls {
    children {
        Decl decl { constructor, mandatory },
        Decls next { constructor }
    }
};

nodeset Decl = { FunDecl, VarDecl };

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    },

    attributes {
        bool always_returns
    }
};

nodeset Stmt = { Assign, IfElse, While, DoWhile, For, Return, Call };

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    },

    attributes {
        bool transp
    }
};

nodeset Expr = { Monop, Binop, Cast, Call, VarRef, Int, Float, Bool };

node ArrExprs {
    children {
        ArrExpr expr { constructor, mandatory },
        ArrExprs next { constructor }
    }
};

nodeset ArrExpr {
    nodes = Expr | { ArrExprs },
    attributes {
        BasicType resolved_ty,
        int resolved_dims,
        bool transp
    }
};

node FunDecls {
    children {
        FunDecl decl { constructor, mandatory},
        FunDecls next { constructor }
    }
};

node FunDecl {
    children {
        Id id { constructor, mandatory },
        Params params { constructor },
        FunBody body
    },

    attributes {
        BasicType ty { constructor },
        bool external,
        bool exported,
        user vartable_ptr vartable,
        int l
    }
};

node FunBody {
    children {
        VarDecls var_decls { constructor },
        FunDecls fun_decls { constructor },
        Stmts stmts { constructor }
    },

    attributes {
        user funtable_ptr funtable
    }
};

node Params {
    children {
        Param param { constructor, mandatory },
        Params next { constructor }
    }
};

node Param {
    children {
        Type ty { constructor, mandatory },
        Id id { constructor, mandatory }
    }
};

node VarDecls {
    children {
        VarDecl decl { constructor, mandatory },
        VarDecls next { constructor }
    }
};

node VarDecl {
    children {
        Type ty { constructor, mandatory },
        Id id { constructor, mandatory },
        ArrExpr expr { constructor }
    },

    attributes {
        bool exported,
        bool external,
        bool global,
        int l
    }
};

node Assign {
    children {
        VarRef ref { constructor, mandatory },
        ArrExpr expr { constructor, mandatory }
    }
};

node IfElse {
    children {
        Expr expr { constructor, mandatory },
        Stmts if_block { constructor },
        Stmts else_block { constructor }
    },

    attributes {
        bool always_returns
    }
};

node While {
    children {
        Expr expr { constructor },
        Stmts stmts { constructor }
    }
};

node DoWhile {
    children {
        Stmts stmts { constructor },
        Expr expr { constructor }
    },

    attributes {
        bool always_returns
    }
};

node For {
    children {
        Id id { constructor, mandatory },
        Expr loop_start { constructor, mandatory },
        Expr loop_end { constructor, mandatory },
        Expr loop_step { constructor, mandatory },
        Stmts stmts { constructor }
    }
};

node Return {
    children {
        Expr expr { constructor }
    }
};

node Monop {
    children {
        Expr expr { constructor, mandatory }
    },

    attributes {
        MonOpKind op { constructor }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    },

    attributes {
        BinOpKind op { constructor }
    }
};

node Cast {
    children {
        Expr expr { constructor, mandatory }
    },

    attributes {
        BasicType ty { constructor }
    }
};

node Call {
    children {
        Id id { constructor, mandatory },
        Exprs exprs { constructor }
    },

    attributes {
        int n,
        int l
    }
};

node VarRef {
    children {
        Id id { constructor, mandatory },
        Exprs exprs { constructor }
    },

    attributes {
        int n,
        int l
    }
};

node Id {
    attributes {
        string val { constructor, mandatory }
    }
};

node Type {
    children {
        Exprs exprs { constructor }
    },

    attributes {
        BasicType ty { constructor }
    }
};

node Int {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};
