start phase RootPhase {
    actions {
        pass scanparse;
        Analysis;
        Desugar;
        MaybeOpt;
        CodeGen;
        Free;
    }
};

traversal Print {
    uid = PRT,
    travdata {
        int indent
    }
};

phase Analysis {
    actions {
        traversal Functions {
            uid = AF,
            nodes = { Program, FunDecl, FunBody },
            travdata {
                user funtable_ptr funtable
            }
        };

        traversal Globals {
            uid = AG,
            nodes = { Program, VarDecl },
            travdata {
                user funtable_ptr funtable,
                user vartable_ptr vartable
            }
        };

        traversal Resolve {
            uid = AR,
            nodes = { Program, FunDecl, FunBody, Param, VarDecl, For, Call, VarRef },
            travdata {
                bool globals,
                user funtable_ptr funtable,
                user vartable_ptr vartable
            }
        };

        traversal TypeCheck {
            uid = ATC,
            nodes = Expr | Stmt | { Program, FunDecl, FunBody, VarDecl, Type },
            travdata {
                user funtable_ptr funtable,
                user vartable_ptr vartable,
                BasicType ret_ty
            }
        };

        traversal DivergeCheck {
            uid = ADC,
            nodes = { Program, Stmts, FunDecl, IfElse, While, DoWhile, Return }
        };
    }
};

phase Desugar {
    actions {
        traversal OwnedTables {
            uid = DOT,
            nodes = { Program, FunDecl, VarDecl, VarRef, Param, Call },
            travdata {
                user funtable_ptr funtable,
                user vartable_ptr vartable
            }
        };

        traversal BoolCasts {
            uid = DBC,
            nodes = { Cast }
        };

        traversal VarDecls {
            uid = DVD,
            nodes = { Program, FunDecl, FunBody, Decls, VarRef, Call },
            travdata {
                user vartable_ptr vartable,
                Stmts stmts
            }
        };

        traversal ImplicitReturns {
            uid = DIR,
            nodes = { FunDecl }
        };

        traversal ArrayParams {
            uid = DAP,
            nodes = { Program, FunDecl, Params, Exprs },
            travdata {
                user vartable_ptr vartable,
                Stmts stmts
            }
        };

        traversal ArrayAssign {
            uid = DAA,
            nodes = { Program, FunDecl, Stmts, Assign, ArrExprs },
            travdata {
                user vartable_ptr vartable,
                Stmts stmts
            }
        };

        traversal DimReduce {
            uid = DDR,
            nodes = { Program, FunDecl, VarRef, Malloc },
            travdata {
                user vartable_ptr vartable
            }
        };

        traversal ForLoops {
            uid = DFL,
            nodes = { Program, FunDecl, Stmts },
            travdata {
                user vartable_ptr vartable
            }
        };

        traversal WhileLoops {
            uid = DWL,
            nodes = { While }
        };
    }
};

phase MaybeOpt {
    gate = is_optimize_enabled,
    actions {
        cycle AstOpt {
            actions {
                CountCalls;

                traversal DeadFunctions {
                    uid = AODF,
                    nodes = { Program, Decls, FunBody },
                    travdata {
                        user funtable_ptr funtable
                    }
                };

                traversal Escapes {
                    uid = AOE,
                    nodes = { Program, FunDecl, VarRef },
                    travdata {
                        user vartable_ptr vartable
                    }
                };

                traversal DirectCaptures {
                    uid = AODC,
                    nodes = { Program, FunDecl, FunBody, VarRef },
                    travdata {
                        user funtable_ptr funtable,
                        int read_capture,
                        int write_capture,
                        int scalar_read_capture,
                        int scalar_write_capture
                    }
                };

                cycle IndirectCaptures {
                    actions {
                        traversal IndirectCalls {
                            uid = AOIC,
                            nodes = { Program, FunDecl, FunBody, Call },
                            travdata {
                                user funtable_ptr funtable,
                                int read_capture,
                                int write_capture,
                                int scalar_read_capture,
                                int scalar_write_capture
                            }
                        };
                    }
                };

                CountWrites;

                traversal CopyProp {
                    uid = AOCP,
                    nodes = { Program, FunDecl, FunBody, Stmts },
                    travdata {
                        Scope parent,
                        user funtable_ptr funtable,
                        user vartable_ptr vartable
                    }
                };

                traversal FunctionSideEffects {
                    uid = AOFSF,
                    nodes = { Program, FunDecl, FunBody },
                    travdata {
                        user funtable_ptr funtable
                    }
                };

                traversal ExprSideEffects {
                    uid = AOESF,
                    nodes = Expr | { Program, FunBody, Exprs },
                    travdata {
                        user funtable_ptr funtable
                    }
                };

                traversal Reassoc {
                    uid = AOR,
                    nodes = { Binop }
                };

                traversal ConstFold {
                    uid = AOCF,
                    nodes = { Monop, Binop, Cast }
                };

                traversal TrivialControlFlow {
                    uid = AOTCF,
                    nodes = { Program, FunBody, Stmts, IfElse, DoWhile, Return },
                    travdata {
                        user funtable_ptr funtable
                    }
                };

                traversal Identities {
                    uid = AOI,
                    nodes = { Monop, Binop, Cast }
                };

                CountReads;

                traversal DeadStores {
                    uid = AODS,
                    nodes = { Program, FunDecl, FunBody, Stmts },
                    travdata {
                        Scope parent,
                        Scope outer_loop,
                        user funtable_ptr funtable,
                        user vartable_ptr vartable
                    }
                };

                traversal LoopUnroll {
                    uid = AOLU,
                    nodes = { Program, FunDecl, FunBody, Stmts },
                    travdata {
                        user funtable_ptr funtable,
                        user vartable_ptr vartable
                    }
                };
            }
        };

        traversal ShrinkTables {
            uid = AOST,
            nodes = { Program, FunDecl, FunBody, Call, VarRef },
            travdata {
                user funtable_ptr funtable,
                user funtable_ptr new_funtable,
                user vartable_ptr vartable,
                user vartable_ptr new_vartable
            }
        };
    }
};

phase CodeGen {
    actions {
        traversal Constants {
            uid = CGC,
            nodes = { Program, Int, Float },
            travdata {
                user consttable_ptr consttable
            }
        };

        traversal Mangling {
            uid = CGM,
            nodes = { Program, FunDecl },
            travdata {
                string name,
                user funtable_ptr funtable
            }
        };

        traversal Assembly {
            uid = CGA,
            nodes = { Program, FunDecl, IfElse, DoWhile, Assign, Call, Stmts, Return, Malloc, Binop, Monop, Cast, VarRef, Int, Float, Bool, ConstRef },
            travdata {
                int label,
                int nesting,
                user funtable_ptr funtable,
                user vartable_ptr vartable,
                user consttable_ptr consttable
            }
        };
    }
};

traversal CountCalls {
    uid = CC,
    nodes = { Program, FunBody, Call },
    travdata {
        user funtable_ptr funtable
    }
};

traversal CountReads {
    uid = CR,
    nodes = { Program, FunDecl, VarRef },
    travdata {
        user vartable_ptr vartable
    }
};

traversal CountWrites {
    uid = CW,
    nodes = { Program, FunDecl, VarRef },
    travdata {
        user vartable_ptr vartable
    }
};

traversal ValueProp {
    uid = VP,
    nodes = Stmt | { Stmts, VarRef },
    travdata {
        VarRef ref,
        Expr expr,
        user funtable_ptr funtable,
        user vartable_ptr vartable
    }
};

traversal ValuePropLoop {
    uid = VPL,
    nodes = { DoWhile, VarRef },
    travdata {
        VarRef ref,
        Expr expr
    }
};

traversal CheckPropLoop {
    uid = CPL,
    nodes = { Stmts, Call, VarRef },
    travdata {
        bool can_prop,
        VarRef ref,
        Expr expr,
        user funtable_ptr funtable,
        user vartable_ptr vartable
    }
};

traversal ExtractStmts {
    uid = ES,
    nodes = { BinOp, Call },
    travdata {
        Stmts stmts
    }
};

traversal CheckDead {
    uid = CD,
    nodes = Stmt | { Stmts, VarRef },
    travdata {
        bool seen,
        bool assign_is_dead,
        bool ref_is_dead,
        VarRef ref,
        user funtable_ptr funtable,
        user vartable_ptr vartable
    }
};

traversal CheckUnroll {
    uid = CU,
    nodes = { IfElse, DoWhile, Assign, Call },
    travdata {
        bool can_unroll,
        VarRef ref,
        int step,
        user funtable_ptr funtable,
        user vartable_ptr vartable
    }
};

traversal CheckUnrollScope {
    uid = CUS,
    nodes = { Assign, call },
    travdata {
        bool can_unroll,
        VarRef ref,
        user funtable_ptr funtable,
        user vartable_ptr vartable
    }
};

traversal EstimateCost {
    uid = EC,
    nodes = Stmt | Expr | { Stmts },
    travdata {
        int cost
    }
};

traversal Free {
    uid = F,
    nodes = { Program, Fundecl, Funbody, Id }
};

node Scope {
    children {
        Expr expr { constructor },
        Stmts stmts { constructor },
        Scope parent { constructor }
    },

    lifetime {
        disallowed
    }
};

enum BasicType {
    prefix = TY,
    values {
        bool, int, float, void, error
    }
};

enum MonOpKind {
    prefix = MO,
    values {
        pos, neg, not
    }
};

enum BinOpKind {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne, and, or
    }
};

root node Program {
    children {
        Decls decls { constructor }
    },

    attributes {
        user consttable_ptr consttable,
        user funtable_ptr funtable,
        user vartable_ptr vartable
    }
};

node Decls {
    children {
        Decl decl { constructor, mandatory },
        Decls next { constructor }
    }
};

nodeset Decl = { FunDecl, VarDecl };

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    },

    attributes {
        bool diverges
    }
};

nodeset Stmt {
    nodes = { Assign, IfElse, While, DoWhile, For, Return, Call },

    attributes {
        bool diverges
    }
};

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    },

    attributes {
        bool side_effects
    }
};

nodeset Expr {
    nodes = { ArrExprs, Monop, Binop, Cast, Call, VarRef, Int, Float, Bool, Malloc, ConstRef },

    attributes {
        BasicType resolved_ty,
        int resolved_dims,
        bool side_effects
    }
};

node ArrExprs {
    children {
        Expr expr { constructor, mandatory },
        ArrExprs next { constructor }
    }
};

node Malloc {
    children {
        Exprs exprs { constructor, mandatory }
    },

    lifetime {
        allowed (Desugar.VarDecls -> )
    }
};

node FunDecl {
    children {
        Id id { constructor, mandatory },
        Params params { constructor },
        FunBody body
    },

    attributes {
        BasicType ty { constructor },
        bool external,
        bool exported,
        user vartable_ptr vartable,
        int l
    }
};

node FunBody {
    children {
        Decls decls { constructor },
        Stmts stmts { constructor }
    },

    attributes {
        user funtable_ptr funtable
    }
};

node Params {
    children {
        Param param { constructor, mandatory },
        Params next { constructor }
    }
};

node Param {
    children {
        Type ty { constructor, mandatory },
        Id id { constructor, mandatory }
    },

    attributes {
        int l
    }
};

node VarDecl {
    children {
        Type ty { constructor, mandatory },
        Id id { constructor, mandatory },
        Expr expr { constructor }
    },

    attributes {
        bool exported,
        bool external,
        bool global,
        int l
    },

    lifetime {
        allowed ( -> Desugar.VarDecls]
    }
};

node Assign {
    children {
        VarRef ref { constructor, mandatory },
        Expr expr { constructor, mandatory }
    }
};

node IfElse {
    children {
        Expr expr { constructor, mandatory },
        Stmts if_block { constructor },
        Stmts else_block { constructor }
    }
};

node While {
    children {
        Expr expr { constructor },
        Stmts stmts { constructor }
    },

    lifetime {
        allowed ( -> Desugar.WhileLoops]
    }
};

node DoWhile {
    children {
        Stmts stmts { constructor },
        Expr expr { constructor }
    },

    attributes {
        bool known_start,
        int unroll_start
    }
};

node For {
    children {
        VarRef ref { constructor, mandatory },
        Expr loop_start { constructor, mandatory },
        Expr loop_end { constructor, mandatory },
        Expr loop_step { constructor, mandatory },
        Stmts stmts { constructor }
    },

    lifetime {
        allowed ( -> Desugar.ForLoops]
    }
};

node Return {
    children {
        Expr expr { constructor }
    }
};

node Monop {
    children {
        Expr expr { constructor, mandatory }
    },

    attributes {
        MonOpKind op { constructor },
        BasicType resolved_ty { constructor }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    },

    attributes {
        BinOpKind op { constructor },
        BasicType resolved_ty { constructor }
    }
};

node Cast {
    children {
        Expr expr { constructor, mandatory }
    },

    attributes {
        BasicType resolved_ty { constructor }
    }
};

node Call {
    children {
        Id id { constructor, mandatory },
        Exprs exprs { constructor }
    },

    attributes {
        int n,
        int l
    }
};

node VarRef {
    children {
        Id id { constructor, mandatory },
        Exprs exprs { constructor }
    },

    attributes {
        bool write,
        int n,
        int l
    }
};

node Id {
    attributes {
        user tablestring val { constructor }
    }
};

node Type {
    children {
        Exprs exprs { constructor }
    },

    attributes {
        BasicType ty { constructor },
        bool array { constructor }
    }
};

node Int {
    attributes {
        int val { constructor },
        BasicType resolved_ty { constructor }
    }
};

node Float {
    attributes {
        double val { constructor },
        BasicType resolved_ty { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor },
        BasicType resolved_ty { constructor }
    }
};

node ConstRef {
    attributes {
        int l { constructor },
        BasicType resolved_ty { constructor }
    },

    lifetime {
        allowed (CodeGen.Constants -> )
    }
};
